def predictLabel(k, s):
	stringInput = sc.parallelize(('', s))
	regex = re.compile('[^a-zA-Z]')
	wordOne = stringInput.flatMap(lambda x: ((j, 1) for j in regex.sub(' ', x).lower().split()))
	wordDicOne = dictionary.join(wordOne)
	oneDic = wordDicOne.map(lambda x: (1, x[1][0]))
	oneDicList = oneDic.groupByKey()
	oneDicCount = listToArray(oneDicList.top(1)[0][1])
	tfInput = np.divide(oneDicCount, np.sum(oneDicCount))
	tfidfInput = np.multiply(tfInput, idf)
	docDis = tfidf.map(lambda x: (x[0], np.linalg.norm(x[1] - tfidfInput)))
	docDisTop = docDis.top(k, lambda x: -x[1])
	docDisTopInput = sc.parallelize(docDisTop)
	regexClassId = re.compile('(/)(.*?)(/)')
	classDis = docDisTopInput.map(lambda x: (regexClassId.search(x[0]).group(2), x[1]))
	classOne = classDis.map(lambda x: (x[0], 1))
	classCount = classOne.reduceByKey(lambda a, b: a + b)
	bestClassId = classCount.top(1, lambda x: x[1])
	return bestClassId[0][0]
